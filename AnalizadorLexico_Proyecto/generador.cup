package comp;

import java.io.*;
import java.util.ArrayList;
import java_cup.runtime.*;

parser code
{:

:}


action code
{:

String r1;
int tipo,op_un;
ArrayList<String> gen=new ArrayList<>();	
			
public void escribir(){

try {			
			PrintWriter salida=new PrintWriter(new FileWriter("salida.txt"));
			for(String s:gen){
				salida.println(s);
			}
			salida.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
}

public void declarar(String id){	
	if(tipo==GeneradorSym.INT||tipo==GeneradorSym.FLOAT||tipo==GeneradorSym.BOOL){
		gen.add("storeAI "+id+" ==> 0");
	}	
}

public void op_unario(){
	if(op_un==GeneradorSym.OP_UNARIO_MAS){
		gen.add("addI "+r1+", 1 ==> "+r1);
	}else{
		gen.add("subI "+r1+", 1 ==> "+r1);
	}
}

public void op_unario2(String id){
	if(op_un==GeneradorSym.OP_UNARIO_MAS){
		gen.add("addI "+id+", 1 ==> "+r1);
	}else{
		gen.add("subI "+id+", 1 ==> "+r1);
	}
}
						
:}


/*los terminales que aun no se usan*/
terminal CARACT_ESP;

terminal PAR_AB,PAR_CER,LLAV_AB,LLAV_CER,COR_AB,COR_CER ;
terminal IGUAL, OP_COMP,OP_COMP_L;
terminal OP_UNARIO_MAS,OP_UNARIO_MENOS,MAS,MENOS,POR,DIV;
terminal CARACTER,ENTERO,FLOTANTE,CADENA,BOOLEANO;
terminal IF,ELSE,THEN,WHILE,DO;
terminal INPUT,OUTPUT,RETURN;


/*Desde cero*/
terminal String ID;
terminal COMA,DOSPUN,END;
terminal int CHAR,INT,FLOAT,STRING,BOOL,VOID;

non terminal PROGRAMA, DECLARACIONES, FUNCIONES;
non terminal TIPO,DEC_G,DEC_G1,DEC_V,DEC_V1;
non terminal FUNCION,FUNC,ENCAB,ENCAB1;
non terminal BLOQUE,BLOQUE1,DEC_L,DEC_L1,DEC_L2,COMANDOS,COMANDOS1;
non terminal ATRIBUCIONES,ATRIBUCIONES1;
non terminal EXPRESION,E,E1,VAL;
non terminal OPR_IN,OPR_OUT,OPR_RTN,OPR_RTN1;
non terminal C_FLUJO_IF,C_FLUJO_ELSE,C_FLUJO_WHILE,C_FLUJO_DOWHILE;
non terminal EXPR_F,EXPR_F1,COMP,COMP1,COMP2;
non terminal LLAM_F,LLAM_F1;

non terminal OP_UNARIO,OP_BINARIO;

PROGRAMA ::= DECLARACIONES FUNCIONES;

/*----DECLARACIONES GLOBALES----*/

DECLARACIONES::= DECLARACIONES DEC_G|DEC_G|DECLARACIONES DEC_V|DEC_V|error END;

/*variables globales*/
DEC_G::= TIPO DOSPUN DEC_G1;
DEC_G1::= ID:r1 END {:declarar(r1);:}
		| ID:r1 COMA {:declarar(r1);:} DEC_G1; 
		
/*vectores*/		
DEC_V::= TIPO DOSPUN DEC_V1;
DEC_V1::= ID:r1 COR_AB ENTERO COR_CER END {:declarar(r1);:}
		| ID:r1 COR_AB ENTERO COR_CER COMA {:declarar(r1);:} DEC_V1;

/*tipos*/		
TIPO ::= INT {:tipo=GeneradorSym.INT;:}
		| FLOAT {:tipo=GeneradorSym.FLOAT;:}
		| CHAR  {:tipo=GeneradorSym.CHAR;:}
		| BOOL  {:tipo=GeneradorSym.BOOL;:}
		| STRING {:tipo=GeneradorSym.STRING;:};
				
		
/*----FUNCIONES----*/
FUNCIONES::= FUNCIONES FUNCION|FUNCION|error;

FUNCION::=FUNC BLOQUE;
/*Declaracion de funcion*/
FUNC::= TIPO DOSPUN ID PAR_AB ENCAB
	|	VOID DOSPUN ID PAR_AB ENCAB;

/*Encabezado*/
ENCAB ::= PAR_CER 
		| TIPO DOSPUN ID ENCAB1 PAR_CER ;		
ENCAB1::= COMA TIPO DOSPUN ID ENCAB1 |;


/*--BLOQUE--*/

BLOQUE::= LLAV_AB DEC_L COMANDOS OPR_RTN LLAV_CER {: escribir(); :} | BLOQUE1;
BLOQUE1::= LLAV_AB COMANDOS LLAV_CER {: escribir(); :}|LLAV_AB LLAV_CER {: escribir(); :};

/*Declaracion variables locales*/
DEC_L::=DEC_L DEC_L1|DEC_L1;
DEC_L1::= TIPO DOSPUN DEC_L2;
DEC_L2::= ID:r1  END {:declarar(r1);:}
		| ID:r1  COMA {:declarar(r1);:} DEC_L2 ;

/*PROGRAMACION QUE SE USARA EN EL BLOQUE*/		
COMANDOS ::= COMANDOS COMANDOS1|COMANDOS1;
COMANDOS1 ::= ATRIBUCIONES
			| OPR_IN
 			| OPR_OUT
 			| C_FLUJO_IF
 			| C_FLUJO_WHILE
 			| C_FLUJO_DOWHILE
			| LLAM_F
 			| error END
 			| error LLAV_CER; 		

/*Para las atribuciones*/
ATRIBUCIONES::= ID:r {:r1=r;:}ATRIBUCIONES1
				|ID:r {:r1=r;:} COR_AB ENTERO COR_CER ATRIBUCIONES1;

ATRIBUCIONES1 ::= OP_UNARIO {:op_unario();:} END
				| IGUAL EXPRESION END;

/*Expresiones matematicas*/
EXPRESION ::= ID:r OP_UNARIO {:op_unario2(r);r1=r;op_unario();:}
			|E;
			
E ::= ID OP_BINARIO E1	
	| VAL OP_BINARIO ID;
	
E1::= ID
	| VAL ;
 
 OP_UNARIO::=OP_UNARIO_MAS {:op_un=GeneradorSym.OP_UNARIO_MAS;:}
 			|OP_UNARIO_MENOS {:op_un=GeneradorSym.OP_UNARIO_MENOS;:};
 			
 
 OP_BINARIO::=MAS
 			|MENOS
 			|POR
 			DIV;

/*Valores*/

VAL::=CADENA 
	| ENTERO 
	| FLOTANTE 
	| CARACTER 
	| BOOLEANO ;

/*Operaciones de entrada y salida*/
OPR_IN ::= INPUT ID  END;
OPR_OUT ::= OUTPUT CADENA END;
OPR_RTN ::= RETURN  OPR_RTN1
		|  ;
		
OPR_RTN1 ::=ID  END
		   |VAL END;

/*Comandos de control de flujo*/			
	C_FLUJO_IF ::= IF PAR_AB EXPR_F PAR_CER THEN BLOQUE1 C_FLUJO_ELSE ;
	C_FLUJO_ELSE ::= ELSE BLOQUE1|;
	
	C_FLUJO_DOWHILE ::= DO BLOQUE1 WHILE PAR_AB EXPR_F PAR_CER END;
	C_FLUJO_WHILE ::= WHILE PAR_AB EXPR_F PAR_CER DO BLOQUE1;
 
/*Declaracion de Expresiones para Operaciones logicas*/
EXPR_F ::= EXPR_F1|ID;
EXPR_F1 ::= EXPR_F1 OP_COMP_L COMP|COMP;
COMP ::= COMP1 OP_COMP  COMP2;
COMP1::= ID  
		|VAL;		
COMP2::= ID 
		|VAL;

/*LLamada a funciones*/
 LLAM_F ::= ID  PAR_AB LLAM_F1 PAR_CER END 
 		|	ID  PAR_AB PAR_CER END ; /*verificamos si la funcion que vamos a llamar no tiene parametros*/
		
		/*verificamos si los tipos de identificadores corresponden a lo que recibe la funcion*/
 LLAM_F1::= ID 
		|	ID COMA LLAM_F1
		/*verificamos si el tipo de datos corresponden a lo que recibe la funcion*/
		|	VAL 
		|	VAL COMA LLAM_F1;